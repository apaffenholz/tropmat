# @category Flips
# Returns some flip of the TropicalOrientedMatroid //T// (towards the [[uniform]] one). Prints the parameters of [[tom_flip]] used for the flip.
# @param TropicalOrientedMatroid T
# @return TropicalOrientedMatroid
user_function find_flip {
	my $t=shift;
	my $n=$t->N_PHP;
	my $d=$t->RANK;
	
	for (my $i=1; $i<$d; ++$i) {
		for (my $j=$i+1; $j<=$d; ++$j) {
			for (my $h1=1; $h1<$n; ++$h1) {
				for (my $h2=$h1+1; $h2<=$n; ++$h2) {
					print "$h1 $h2 $i $j\n";
					if (my $ret=tom_flip($t,$h1,$h2,$i,$j,1)) {
#						print "$h1 $h2 $i $j\n";
						print "works\n";
						return $ret;
					}
				}
			}
		}
	}
	print "no flip available";
}

# @category Flips
# Tries to flip the TropicalOrientedMatroid //T// to the [[uniform]] one. Prints the parameters of each flip.
# @param TropicalOrientedMatroid T
user_function flip_to_uniform {
	my $t=shift;
	while (1) {
		my $f=find_flip($t);
		if ($f->IS_UNIFORM) {return;}
		$t=$f;
	}
}


# @category Flips
# @param TropicalOrientedMatroid T
# @param Int h1 index of the first hyperplane involved
# @param Int h2 index of the second hyperplane involved
# @param Int i
# @param Int j
# @param Bool verbose default=1
# @return TropicalOrientedMatroid
user_function tom_flip {
	my ($t,$h1,$h2,$i,$j,$v)=@_;
	unless (defined($v)) {$v=1;}

	unless(flippable($t,$h1,$h2,$i,$j,$v)) {
		return;
	}

	my $topes=$t->TOPES;
	my @ntopes=();
	
	foreach my $tope (@$topes) {
		my @ntope=@$tope;
		if ($tope->[$h1-1]->[0]==$i && $tope->[$h2-1]->[0]==$j) {
			$ntope[$h1-1]=[$j];
			$ntope[$h2-1]=[$i];
		} 
		push(@ntopes,\@ntope);

	}
	return new TropicalOrientedMatroid(TOPES=>\@ntopes);
}


sub flippable {
	my ($tom,$h1,$h2,$i,$j,$verb)=@_;
	
	my $a1=$tom->APEX($h1);
	my $a2=$tom->APEX($h2);

	my $si=new Set; $si+=$i;
	my $sj=new Set; $sj+=$j;
	
	# it may not be that apex1 is in sector i of h2 and apex2 is in sector j of h1 since then there is a tope containing both apices and we don't know what to do
	if ($a1->[$h2-1]==$sj and $a2->[$h1-1]==$si) {
		if ($verb) {print "flip not well-defined: there is a tope containing both apices\n";}
		return 0;
	}

	# but one apex must be contained in the corresponding sector of the other
	unless ($a1->[$h2-1]==$sj or $a2->[$h1-1]==$si) {
		if ($verb) {print "flip not well-defined: one apex must be contained in correct sector of the other hyperplane\n";}
		return 0;
	}

	my @p=(); push(@{$p[$h1-1]},$i); push(@{$p[$h2-1]},$j);
	my $v=filter($tom,\@p);
	foreach my $x (@$v) {
		unless (contains($x->[$h1-1],$sj) or contains($x->[$h2-1],$si)) {
			if ($verb) {print "flip not well-defined: there is a hyperplane whose $i$j-face is sandwiched between those of $h1 and $h2\n";}
			return 0;
		}
	}
	
#	my $vertices=$tom->VERTICES;
	
#	foreach my $v (@$vertices) {
		# it remains to make sure that there is no third hyperplane whose ij-face is sandwiched between those of h1 and h2
#		if ($v->[$h1-1]==$si and $v->[$h2-1]==$sj) {
#			if ($verb) {print "flip not well-defined: there is a hyperplane whose $i$j-face is sandwiched between those of $h1 and $h2\n";}
#			return 0;
#		}
		
		# finally it may be that this flip is the inverse of an admissable flip
#		if (contains($v->[$h1-1],$sj) and contains($v->[$h2-1],$si)) {
#			if ($verb) {print "nothing to flip -- you may try the inverse (by swapping i=$i and j=$j)";}
#			return 0;
#		}
#	}
		
	
#	my $s= new Set($i,$j);
#	foreach my $v (@$vertices) {
#		if ($v->[$h1-1]==$s) {
#			if (neighs($v,$a2,$tom->RANK)) {
#				printtype($v); print "\n$a2\n"; 
#				return 1;
#			}
#		} elsif ($v->[$h2-1]==$s) {
#			if (neighs($v,$a1,$tom->RANK)) {
#				printtype($v); print "\n$a1\n"; 
#				return 1;
#			}
#		}
#	}
	
#	if ($verb){print "flip not well-defined: apex too far from hyperplane\n";}
	return 1;
}

sub printtype {
	my $t=shift;
	foreach (@$t) {print "{@$_} "};
}

# @category Type manipulation
# Returns the intersection of //type1// and //type2// if this is a type.
# @param Array<Set<Int>> type1
# @param Array<Set<Int>> type1
# @return Array<Set<Int>> of 0 if not a type
user_function type_intersection {
	my ($t1, $t2)=@_;
	my @intersection=();
	
	for (my $i=0; $i<@$t1; ++$i) {
		my $is=$t1->[$i]*$t2->[$i];
		if (@$is==0) {return 0;}
		push(@intersection,$is);
	}
	return \@intersection;
}


sub neighs {
	my ($t1,$t2,$d)=@_;
	my $i=type_intersection($t1,$t2);
	if ($i) {
		if (rank($i,$d)==2) {
			return 1;
		}
	}
	return 0;
}
