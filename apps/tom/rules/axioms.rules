object TropicalOrientedMatroid {

# @category Axioms
# The __elimination__ of two types //A// and //B// with respect to a position //j// is a type C such that C<sub>j</sub>=A<sub>j</sub>&cup;B<sub>j</sub> and C<sub>i</sub>&isin;{A<sub>i</sub>, B<sub>i</sub>, A<sub>i</sub>&cup;B<sub>i</sub>} for each i&isin;[d] (where d=[[RANK]]).
# This method tries to compute the elimination by brute force search (rather slow). Written in perl -- should be done in c++
# @param Array<Set<Int>> A
# @param Array<Set<Int>> B
# @param Int j
# @return Array<Set<Int>> C or 0 if elimination does not exist
user_method ELIMINATION : TYPES, N_PHP {
	my ($self, $type1, $type2, $j) = @_;
	my $t1 = @{$type1};
	my $t2 = @{$type2};
	if ($t1 != $t2 or $t1 !=$self->N_PHP) {
		die "input types do not have correct length";
	}
	if ($j<1 or $j>$self->N_PHP) {
		die "position must be contained in [$self->N_PHP]."
	}
	
	$j=$j-1;

	my $s1=new Set<Int>($type1->[$j]);
	my $s2=new Set<Int>($type2->[$j]);
	my $sunion=$s1+$s2;
	OUTERLOOP: foreach (@{$self->TYPES}) {
		my $set = new Set<Int>($_->[$j]);
		unless ($set==$sunion) {
			next;
		}
		my $cur = $_;
		for (my $i=0; $i<$self->N_PHP; ++$i) {
			unless (elim_sat($type1->[$i], $type2->[$i], $cur->[$i])) {
				next OUTERLOOP;
			}
		}
		
		return $cur;
	}
	return 0;
}
weight 2.0;


# @category Axioms
# Faster method to compute the [[ELIMINATION]] of two types //A// and //B//.
# @param Array<Set<Int>> A
# @param Array<Set<Int>> B
# @param Int j
# @return Array<Set<Int>> C or 0 if elimination does not exist
user_method FAST_ELIMINATION : VERTICES, N_PHP, RANK {

	my ($self, $type1, $type2, $j) = @_;
	my $t1 = @{$type1};
	my $t2 = @{$type2};
	if ($t1 != $t2 or $t1 !=$self->N_PHP) {
		die "input types do not have correct length";
	}
	if ($j<1 or $j>$self->N_PHP) {
		die "position must be contained in [$self->N_PHP]."
	}
	
	$j=$j-1;

	my $s1=new Set<Int>($type1->[$j]);	# A_j
	my $s2=new Set<Int>($type2->[$j]);	# B_j
	my $s3=$s1+$s2;						# C_j
	
	OUTERLOOP: foreach (@{$self->VERTICES}) {	# go through all vertices
		
		if (contains($_->[$j], $s3)) {	# check j-th entry
			
			my $cur = $_;	# this is a candidate for the elimination
			
			for (my $i=0; $i<$self->N_PHP; ++$i) {	# check the other entries
				if (!elim_contains($type1->[$i], $type2->[$i], $cur->[$i])) {
					next OUTERLOOP;
				}
			}
			# if we are here then the current vertex contains something that could be the elimination
			
			my @op = ();	# ordered partition
			push(@op,$s1+$s2);
			my $r=$self->REFINEMENT($cur,\@op);
			
			# FIXME we're not done here
			return $r;
		}
	}
	return 0;
}
weight 1.5;



sub elim_sat {
	# check whether c equals one of t1, t2 or t1+t2
	my ($t1, $t2, $c) = @_;

	my $s1=new Set<Int>(@{$t1});
	my $s2=new Set<Int>(@{$t2});
	my $s=new Set<Int>(@{$c});

	return ($s==$s1 or $s==$s2 or $s==$s1+$s2);
}

sub elim_contains {
	# check whether c is contained in one of t1, t2 or t1+t2
	my ($t1, $t2, $c) = @_;

	my $s1=new Set<Int>(@{$t1});
	my $s2=new Set<Int>(@{$t2});
	my $s=new Set<Int>(@{$c});

	return (contains($s,$s1+$s2));
}


# @category Axioms
# Returns true if the given type //type// is contained in the tropical oriented matroid. Only works for toms in [[GENERAL_POSITION]]
# @param Array<Set<Int>> type
# @return Bool
user_method CONTAINS : VERTICES, N_PHP {
	my ($self, $type) = @_;
		
	my @vs = @{$self->VERTICES};
	my @t = @{$type};
	my $t = @t;
	
	LOOP: for (my $i=0; $i<@vs; ++$i) {		# go thru all vertices
		my @v=@{$vs[$i]};
	
		if (@v!=$t) {
			die "input type does not have correct length";
		}
		
		for (my $j=0; $j<@t; ++$j) {	#go thru sets in input type
			if (!contains($v[$j],$t[$j])) {
				next LOOP;
			}
		}
		return 1;
	}
	return 0;
}
precondition : GENERAL_POSITION;
weight 2.00;

# @category Axioms
# Returns the __refinement__ of a given type //type// with respect to an ordered partition //ord_part// of [d],
# where d=[[RANK]].
# @param Array<Set<Int>> type
# @param Array<Set<Int>> ord_part an ordered partition of [d]
# @return Array<Set<Int>>
# 
user_method REFINEMENT {
	my ($self, $type, $ordp) = @_;
	my @t = @{$type};
	my @o = @{$ordp};
	
	my @r=();
	
	TYPE: foreach (@t) {			# go thru input type
		my $a=new Set<Int>($_);
		foreach (@o) {		# go thru sets in ordered partition
			my $b=new Set<Int>($_);
			my @i= @{$a*$b};#@{intersect($a,$_)};
			if (@i) {
				push(@r,\@i);
				next TYPE;
			}
		}
		push(@r,$a);	# take care of the case where we do only have a partial ordered partition (i.e., last set is omitted)
	}
	return new Array<Set<Int>>(@r);
}

sub refine_one_entry {
	my ($entry, $ordp) = @_;	# entry is a Set<Int>, ordp is an ordered partition
	my $a=new Set<Int>($entry);
	
	foreach (@$ordp) {
		my $b=new Set<Int>($_);
		my @i= @{$a*$b};
		if (@i) {
			return new Set<Int>(@i);
		}
	}	
	return $a;
}
sub refine_whole_type {
	my ($type, $ordp) =@_;
	my @r=();
	
	foreach (@$type) {
		push @r, refine_one_entry($_, $ordp);
	}
	return @r;
}

}