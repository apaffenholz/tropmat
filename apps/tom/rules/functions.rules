# @category Producing from scratch
# Produces the uniform tropical oriented matroid with parameters //n// and //d//. I.e., the (unique) tropical oriented matroid in [[GENERAL_POSITION]] all of whose [[TOPES]] are decreasing. (Note that I could also have chosen increasing but decreasing was faster to implement.)
# @param Int n
# @param Int d
# @return TropicalOrientedMatroid
user_function uniform {
	my $n=shift; my $d=shift;
	my $t=new TropicalOrientedMatroid(VERTICES=>[[[1..$d]]]);
	
	my $s=$t;
	for (my $i=1; $i<$n; ++$i) {
		$s=$t->N_PLACING;
		$t=$s;
	}
	return $t;
}

# @category Producing from given data
# Produces the (realisable) tropical oriented matroid of a given tropical polytope //T//. (Just to help off the rather deplorable fact that the application ''tropical oriented matroid'' used every other application except ''tropical'' and ''matroid''.)
# @param tropical::TropicalPolytope T
# @return TropicalOrientedMatroid
user_function tom_from_tropical_polytope {
	my $poly=shift;
	
	my @vs=@{$poly->PSEUDOVERTEX_TYPES};
	my @tvs=();	# vertices of tom (add 1 everywhere)
	
	foreach (@vs) {		# go thru list of type
		my @vertex=@{$_}; 
		my @newvertex=();
		for (my $i=0; $i<@vertex; ++$i) {	# go thru entries of current vertex
			my @newentry=();
			for (my $j=0; $j<@{$vertex[$i]}; ++$j) {	# go thru elts of current entry
				my $tmp=$vertex[$i]->[$j];
				push(@newentry,$tmp+1);
			}
			push(@newvertex,\@newentry);
		}
		push(@tvs,\@newvertex);
	}

	return new TropicalOrientedMatroid(VERTICES=>\@tvs);
}


# @category Type manipulation
# The __dual__ of the (//n//,//d//)-type //t// is a (//d//,//n//)-type.
# @param Array<Set<Int>> t an (n,d)-type
# @param Int n
# @param Int d
# @return Array<Set<Int>>
user_function dual_type {
	my ($t,$n,$d)=@_;
	
	my @r=();
	
	for (my $i=0; $i<@$t; ++$i) {
		foreach (@{$t->[$i]}) {
			push(@{$r[$_-1]},$i+1);
		}
	}
	return \@r;
}

# @category Basic properties
# Returns a list of all [[VERTICES]] of //t// that contain the given pretype //p//.
# @param TropicalOrientedMatroid t
# @param Array<Set<Int>> p pretype; note that there may be empty positions
# @return Array<Array<Set<Int>>>
user_function filter {
	my ($t,$p)=@_;
	my @r=();
	my $v=$t->VERTICES;
	LOOP: foreach my $c (@$v) {
		for (my $i=0; $i<@$c; ++$i) {
			if (!contains($c->[$i],$p->[$i])) {
				next LOOP;
			}
		}
		push(@r,$c);
	}
	return \@r;
}

# @category Basic properties
# Returns a list of all [[VERTICES]] of //t// that contain the given coarse pretype //p//.
# @param TropicalOrientedMatroid t
# @param Array<Int> p coarse pretype
# @return Array<Array<Set<Int>>>
user_function coarse_filter {
	my ($t,$p)=@_;
	my @r=();
	my $v=$t->VERTICES;
	LOOP: foreach my $c (@$v) {
		for (my $i=0; $i<@$c; ++$i) {
			if (@{$c->[$i]}<$p->[$i]) {
				next LOOP;
			}
		}
		push(@r,$c);
	}
	return \@r;
}


# @category Mixed subdivisions
# Returns the face of a standard //d//-simplex spanned by the vertices in //vertices//.
# @param Int d the dimension of the simplex
# @param Set<Int> vertices the labels of the vertices (starting from 0)
# @return Polytope
user_function simplex_face {
	my ($d, @l) = @_;
	my $l = @l;
	my @vs = ()	;
	
	for (my $i=0; $i<$l; ++$i) {
		# create a vector with one at positions 0 and i+1 and 0 elsewhere
		# to be replaced with unit_vector

		my @v = ();
		push(@v,1);
		
		for (my $j=0; $j<$d; ++$j) {
			if ($l[$i]==$j+1) {
				push(@v,1);
			} else {
				push(@v,0);
			}
		}
		push(@vs,\@v);
	}
	
	
	my $s = new polytope::Polytope<Float>(VERTICES=> \@vs);
	return $s;	
}


# @category Mixed subdivisions
# Computes the Minkowski sum of the given simplex faces.
# Each face is given as a list of its vertices, where the vertices are labeled
# starting from 0.
# @param Array<Set<Int>> faces
# @param Int d the dimension of the big simplex
# @return Polytope
user_function minkowski_cell {
	
	my ($ll, $d) = @_;
	my @l = @{$ll};
	my $l = @l;
	my $zero=new Vector<Float>($d);
	my $origin=new polytope::Polytope<Float>(VERTICES => [(1|$zero)]);
	
	my $m = $origin;
	for (my $i=0; $i<$l; ++$i) {

		my $temp = &simplex_face($d, @{$l[$i]});
		$m = polytope::minkowski_sum(1,$m,1,$temp);
	}	
	return $m;	
} 


# return true if elt is contained in set
sub cont_elt {
	my ($set, $elt)=@_;

	foreach (@{$set}){
		if ($_ == $elt){
			return 1;
		}
	}
	return 0;
}

sub contains {
	my ($set, $ss)=@_;
	foreach (@$ss) {
		unless (cont_elt($set,$_)) {
			return 0;
		}
	}
	return 1;
}

