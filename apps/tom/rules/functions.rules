# @category Producing from scratch
# Produces the uniform tropical oriented matroid with parameters //n// and //d//.
# @param Int n
# @param Int d
# @return TropicalOrientedMatroid
user_function uniform {
	my $n=shift; my $d=shift;
	my $t=new TropicalOrientedMatroid(VERTICES=>[[[1..$d]]]);
	
	my $s=$t;
	for (my $i=1; $i<$n; ++$i) {
		$s=$t->N_PLACING;
		$t=$s;
	}
	return $t;
}

# @category Producing from given data
# Produces the (realisable) tropical oriented matroid of a given tropical polytope //T//. (Just to help off the rather deplorable fact that the application ''tropical oriented matroid'' used every other application except ''tropical'' and ''matroid''.)
# @param tropical::TropicalPolytope T
# @return TropicalOrientedMatroid
user_function tom_from_tropical_polytope {
	my $poly=shift;
	
	my @vs=@{$poly->PSEUDOVERTEX_TYPES};
	my @tvs=();	# vertices of tom (add 1 everywhere)
	
	foreach (@vs) {		# go thru list of type
		my @vertex=@{$_}; 
		my @newvertex=();
		for (my $i=0; $i<@vertex; ++$i) {	# go thru entries of current vertex
			my @newentry=();
			for (my $j=0; $j<@{$vertex[$i]}; ++$j) {	# go thru elts of current entry
				my $tmp=$vertex[$i]->[$j];
				push(@newentry,$tmp+1);
			}
			push(@newvertex,\@newentry);
		}
		push(@tvs,\@newvertex);
	}

	return new TropicalOrientedMatroid(VERTICES=>\@tvs);
}

# @category Producing a polytope
# Returns the face of a standard //d//-simplex spanned by the vertices in //vertices//.
# @param Int d the dimension of the simplex
# @param Set<Int> vertices the labels of the vertices (starting from 0)
# @return Polytope
user_function simplex_face {
	my ($d, @l) = @_;
	my $l = @l;
	my @vs = ()	;
	
	for (my $i=0; $i<$l; ++$i) {
		# create a vector with one at positions 0 and i+1 and 0 elsewhere
		# to be replaced with unit_vector

		my @v = ();
		push(@v,1);
		
		for (my $j=0; $j<$d; ++$j) {
			if ($l[$i]==$j+1) {
				push(@v,1);
			} else {
				push(@v,0);
			}
		}
		push(@vs,\@v);
	}
	
	
	my $s = new polytope::Polytope<Float>(VERTICES=> \@vs);
	return $s;	
}


# @category Producing a polytope
# Computes the Minkowski sum of the given simplex faces.
# Each face is given as a list of its vertices, where the vertices are labeled
# starting from 0.
# @param Array<Set<Int>> faces
# @param Int d the dimension of the big simplex
# @return Polytope
user_function minkowski_cell {
	
	my ($ll, $d) = @_;
	my @l = @{$ll};
	my $l = @l;
	my $zero=new Vector<Float>($d);
	my $origin=new polytope::Polytope<Float>(VERTICES => [(1|$zero)]);
	
	my $m = $origin;
	for (my $i=0; $i<$l; ++$i) {

		my $temp = &simplex_face($d, @{$l[$i]});
		$m = polytope::minkowski_sum(1,$m,1,$temp);
	}	
	return $m;	
} 


# @category Producing from given data
# @param TropicalOrientedMatroid T
# @param Int h1 index of the first hyperplane involved
# @param Int h2 index of the second hyperplane involved
# @param Int i
# @param Int j
# @return TropicalOrientedMatroid
user_function tom_flip {
	my ($t,$h1,$h2,$i,$j)=@_;

	unless(flippable($t,$h1,$h2,$i,$j)) {
		die "flip not well-defined";
	}

	my $topes=$t->TOPES;
	my @ntopes=();
	
	foreach my $tope (@$topes) {
		my @ntope=@$tope;
		if ($tope->[$h1-1]->[0]==$i && $tope->[$h2-1]->[0]==$j) {
			$ntope[$h2-1]=[$i];
			$ntope[$h1-1]=[$j];
		} elsif ($tope->[$h1-1]->[0]==$j && $tope->[$h2-1]->[0]==$i) {
			$ntope[$h2-1]=[$j];
			$ntope[$h1-1]=[$i];
		}
		push(@ntopes,\@ntope);

	}
	return new TropicalOrientedMatroid(TOPES=>\@ntopes);
}


sub flippable {
	my ($tom,$h1,$h2,$i,$j)=@_;
	
	my $a1=$tom->APEX($h1);
	my $a2=$tom->APEX($h2);

	my $si=new Set; $si+=$i;
	my $sj=new Set; $sj+=$j;
	
	if (($a1->[$h2-1]==$si and $a2->[$h1-1]==$sj) or ($a1->[$h2-1]==$sj and $a2->[$h1-1]==$si)) {
		return 0;
	}
	
	my $vertices=$tom->VERTICES;
	
	foreach my $v (@$vertices) {
		if (($v->[$h1-1]==$si and $v->[$h2-1]==$sj) or ($v->[$h2-1]==$si and $v->[$h1-1]==$sj)) {
			print $v;
			return 0;
		}
	}
	
	return 1;
}


# return true if elt is contained in set
sub cont_elt {
	my ($set, $elt)=@_;

	foreach (@{$set}){
		if ($_ == $elt){
			return 1;
		}
	}
	return 0;
}

sub contains {
	my ($set, $ss)=@_;
	foreach (@$ss) {
		unless (cont_elt($set,$_)) {
			return 0;
		}
	}
	return 1;
}

